# Лекция «Анализ данных. Визуализация. Классы и Объекты»

## 1. Введение в классы и объекты в Python
Прежде чем перейти к анализу данных и визуализации, важно понять основы
объектно-ориентированного программирования (ООП), так как оно является
основой многих современных библиотек Python, включая те, что
используются для анализа данных, такие как pandas, matplotlib, и
seaborn.
### 1. Что такое классы и объекты?
-   **Класс** — это шаблон для создания объектов. Он определяет свойства
    и поведение, которые будут у объектов этого класса. Класс описывает
    структуру данных и методы, которые могут работать с этими данными.

-   **Объект** — это экземпляр класса. Когда вы создаёте объект, вы
    используете класс как шаблон для определения его характеристик
    и поведения.

**Пример: Создание класса**

Представим, что мы хотим создать класс для представления **Продукта** в
магазине. У каждого продукта есть название, цена и количество на складе.
Мы также хотим, чтобы класс мог обновлять количество и вычислять общую
стоимость товара.
```
class Product:

    def __init__(self, name, price, quantity):
        self.name = name # Свойство: название
        self.price = price # Свойство: цена*
        self.quantity = quantity # Свойство: количество*


    def update_quantity(self, amount):
    #*"""Обновить количество товара."""*
        self.quantity += amount


    def total_cost(self):
    #*"""Вычислить общую стоимость товара на складе."""*
        return self.price * self.quantity


#Создание объектов
product1 = Product("Laptop", 1500, 5)
product2 = Product("Smartphone", 800, 10)

# Взаимодействие с объектами*
print(f"Общая стоимость {product1.name}: {product1.total_cost()}") #7500*
product1.update_quantity(-1) # Продажа одного товара*
print(f"Обновленное количество {product1.name}: {product1.quantity}")# 4*
```

**Объяснение:**

-   **\_\_init\_\_**: Это конструктор, который вызывается при создании
    нового объекта. Он принимает параметры, которые инициализируют
    свойства объекта.

-   **self**: Это ссылка на текущий экземпляр объекта. Используется для
    доступа к его свойствам и методам.

-   **Методы**: Функции, определённые внутри класса, которые выполняют
    действия с объектом. В данном примере методы — это update\_quantity
    и total\_cost.

### 2. Почему важно использовать ООП в анализе данных?

1.  **Чистота кода**: ООП помогает сделать код более понятным,
    организованным и модульным. Классы и объекты позволяют разделять
    логику на отдельные компоненты.

2.  **Повторное использование кода**: Создавая классы, вы можете
    повторно использовать их в разных частях программы, не дублируя код.

3.  **Инкапсуляция**: Все данные и функции, которые манипулируют этими
    данными, хранятся внутри одного класса, что делает код более
    устойчивым и безопасным.

4.  **Легкость в расширении**: Когда появляется необходимость добавить
    новую функциональность, вы можете просто расширить существующий
    класс или создать новый, что облегчает поддержку кода.
## 2. Классы и объекты в анализе данных

В этом разделе мы продолжим рассматривать, как объекты и классы могут
быть полезными при анализе данных. Классы позволяют вам создать более
структурированный подход к организации данных и операций с ними.

### 1. Классы для работы с данными

Допустим, у нас есть набор данных о пациентах, и мы хотим создать класс,
который будет управлять этими данными. Например, для медицинских данных
класс может хранить информацию о пациенте и вычислять статистику, такую
как средний возраст.

**Пример: Класс для работы с пациентами**

```
class Patient:

    def __init__(self, name, birth_year, gender):
        self.name = name # Имя пациента
        self.birth_year = birth_year # Год рождения*
        self.gender = gender # Пол пациента*


    def age(self, current_year):
    #*"""Вычислить возраст пациента на основе текущего года."""*
        return current_year - self.birth_year


    def __str__(self):
    #*"""Возвращает строковое представление объекта."""*
        return f"{self.name}, {self.age(2024)} лет, {self.gender}"

# Создание объектов
patient1 = Patient("Иван Иванов", 1985, "мужчина")
patient2 = Patient("Мария Петрова", 1990, "женщина")
```

**Объяснение:**

-   **Метод age**: Рассчитывает возраст пациента, используя год рождения
    и текущий год.

-   **Метод \_\_str\_\_**: Этот метод позволяет красиво выводить
    информацию об объекте. Когда мы используем print(patient1), Python
    вызывает этот метод, чтобы получить строковое представление объекта.
### 2. Обработка и анализ данных с использованием классов

Теперь давайте рассмотрим, как можно использовать классы для обработки
данных. Пусть у нас есть набор данных о пациентах, и мы хотим
анализировать возраст и пол пациентов.

**Пример: Класс для анализа данных о пациентах**
```
class PatientData:

    def __init__(self):
        self.patients = [] # Список пациентов*


    def add_patient(self, patient):
    #*"""Добавить пациента в список."""
        self.patients.append(patient)


    def average_age(self, current_year):
    #*"""Вычислить средний возраст всех пациентов."""
        total_age = sum([patient.age(current_year) for patient in self.patients])
        return total_age / len(self.patients)


    def gender_distribution(self):
    #*"""Подсчитать распределение по полу."""
        male = sum([1 for patient in self.patients if patient.gender == "мужчина"])
        female = len(self.patients) - male
        return {"мужчина": male, "женщина": female}

# Создание объектов пациентов*
patient_data = PatientData()
patient_data.add_patient(Patient("Иван Иванов", 1985, "мужчина"))
patient_data.add_patient(Patient("Мария Петрова", 1990, "женщина"))
patient_data.add_patient(Patient("Алексей Смирнов", 1980, "мужчина"))

# Анализ данных*
print(f"Средний возраст: {patient_data.average_age(2024)} лет") # Средний возраст
print(f"Распределение по полу: {patient_data.gender_distribution()}") # Распределение по полу
```

**Объяснение:**

-   **add\_patient**: Метод для добавления пациента в список.

-   **average\_age**: Метод для вычисления среднего возраста
    всех пациентов. Для этого мы используем список всех пациентов и
    метод age из класса Patient.

-   **gender\_distribution**: Метод для подсчета распределения по полу.

### 3. Преимущества использования классов для анализа данных:

-   **Модульность**: Каждый класс и метод отвечает за определенную часть
    программы, что упрощает тестирование и поддержку.

-   **Инкапсуляция**: Вся информация и логика работы с данными находятся
    внутри класса, что предотвращает ошибки и делает код
    более безопасным.

-   **Расширяемость**: Вы можете легко добавлять новые методы или
    изменять существующие, не затрагивая другие части программы.

## 3. Классы и объекты для визуализации данных

Теперь, когда мы разобрались с основами классов и объектов, а также с их
применением для работы с данными, давайте рассмотрим, как можно
использовать объектно-ориентированный подход для визуализации данных с
помощью таких библиотек, как matplotlib и seaborn.

### 1. Классы для визуализации данных

Когда мы работаем с визуализацией, часто нужно организовать графики,
диаграммы и другие визуальные элементы в классы, чтобы повысить гибкость
и масштабируемость кода. Визуализация данных часто требует многократного
использования одних и тех же настроек и методов.

#### Пример: Класс для построения графиков

Создадим класс, который будет отвечать за визуализацию данных, например,
для построения гистограмм, линейных графиков и других видов
визуализаций.
```
import matplotlib.pyplot as plt


class DataVisualizer:

    def __init__(self, data: list):
        self.data = data # Данные, которые будем визуализировать


    def plot_histogram(self, bins=10):
    #*"""Построить гистограмму."""*
        plt.hist(self.data, bins=bins, edgecolor='black')
        plt.title('Гистограмма данных')
        plt.xlabel('Значения')
        plt.ylabel('Частота')
        plt.show()
  

    def plot_line(self, x, y):
    #*"""Построить линейный график."""
        plt.plot(x, y, marker='o', color='b')
        plt.title('Линейный график')
        plt.xlabel('X')
        plt.ylabel('Y')
        plt.show()


    def plot_scatter(self, x, y):
    #*"""Построить диаграмму рассеяния."""*
        plt.scatter(x, y, color='r')
        plt.title('Диаграмма рассеяния')
        plt.xlabel('X')
        plt.ylabel('Y')
        plt.show()


if __name__ == "__main__":
    #Пример данных
    data = [1, 2, 2, 3, 3, 3, 4, 4, 5, 6, 6, 6, 7, 7, 8, 9, 9, 9, 10]

    #Создание объекта визуализатора
    visualizer = DataVisualizer(data)

    #Построение гистограммы
    #visualizer.plot_histogram(bins=5)

    #Построить график функции
    x = [1,2,3,4,5]
    y = [2,4,6,8,10]

    #visualizer.plot_line(x, y)
    #Построить диаграмму рассеяния

    visualizer.plot_scatter(x, y)
```


**Объяснение:**

-   **plot\_histogram**: Метод для построения гистограммы. Мы передаем
    количество столбцов (bins) для гистограммы.

-   **plot\_line**: Метод для построения линейного графика. Мы передаем
    два списка (x и y), которые будут отображены на осях X и Y.

-   **plot\_scatter**: Метод для построения диаграммы рассеяния, где
    каждый точечный элемент представляет собой пару значений из списков
    x и y.

### 2. Усовершенствование класса для дополнительных графиков

Допустим, теперь нам нужно добавить еще несколько методов для работы с
другими типами графиков, например, для построения боксплотов и тепловых
карт. Мы можем расширить класс DataVisualizer и добавлять новые методы.

**Пример: Расширенный класс для различных визуализаций**


```
import seaborn as sns
import numpy as np


class ExtendedDataVisualizer(DataVisualizer):

    def __init__(self, data):
        super().__init__(data) #Наследуем от DataVisualizer*


    def plot_boxplot(self):
     #*"""Построить боксплот."""*
        sns.boxplot(data=self.data)
        plt.title('Боксплот данных')
        plt.show()


    def plot_heatmap(self, matrix):
    #"""Построить тепловую карту."""*
        sns.heatmap(matrix, annot=True, cmap='coolwarm')
        plt.title('Тепловая карта')
        plt.show()

#Пример данных*
data = np.random.randn(100)

#Создание объекта для расширенной визуализации*
extended_visualizer = ExtendedDataVisualizer(data)

#Построение боксплота*
extended_visualizer.plot_boxplot()

#Пример для тепловой карты*
matrix = np.random.rand(10, 10)
extended_visualizer.plot_heatmap(matrix)
```

**Объяснение:**

-   **Наследование**: Мы использовали наследование, чтобы расширить
    функциональность класса DataVisualizer и добавить новые методы для
    построения боксплота и тепловой карты.

-   **Тепловая карта**: Для построения тепловой карты используется
    библиотека seaborn, которая упрощает создание таких графиков.

### 3. Преимущества использования классов для визуализации данных:

-   **Повторное использование кода**: Классы позволяют вам организовать
    код так, чтобы однотипные визуализации можно было строить
    многократно с минимальными усилиями.

-   **Гибкость**: Легко добавлять новые типы визуализаций в класс, что
    делает ваш код более гибким и расширяемым.

-   **Инкапсуляция**: Весь код, связанный с визуализацией, находится
    внутри одного класса, что упрощает поддержку и понимание программы.

## 4. Интеграция классов и объектов в проекты анализа данных

В этом разделе мы рассмотрим, как интегрировать классы и объекты в
реальный проект анализа данных. Мы построим простое приложение для
анализа набора данных и визуализации результатов. Используем библиотеки,
такие как pandas, matplotlib, и seaborn, для работы с данными и
визуализации.

### 1. Создание проекта для анализа данных

Предположим, у нас есть набор данных о продажах товаров в магазине, и мы
хотим проанализировать его с помощью классов и объектов.

**Пример: Класс для работы с данными о продажах**

```
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns


class SalesData:

    def __init__(self, data):
        self.data = pd.DataFrame(data) #Инициализируем данные как DataFrame
        self.processed_data = None
  

    def clean_data(self):
    #"""Очистка данных: удаление пропущенных значений."""
        self.data.dropna(inplace=True)
    #"""Добавление нового столбца для общей стоимости товаров."""
        self.data['TotalSales'] = self.data['Quantity']
        self.data['Price']
 

    def summary_statistics(self):
    #*"""Возвращает описательную статистику."""
        return self.data.describe()


    def plot_sales_distribution(self):
    #"""Построить распределение продаж."""
        plt.figure(figsize=(10, 6))
        sns.histplot(self.data['TotalSales'], bins=20, kde=True)
        plt.title('Распределение продаж')
        plt.xlabel('Общая стоимость продаж')
        plt.ylabel('Частота')
        plt.show()

# Пример данных о продажах
data = {
'Product': ['Product A', 'Product B', 'Product C', 'Product D','Product E'],
'Quantity': [100, 150, 200, 250, 300],
'Price': [10, 15, 20, 25, 30]
}

# Создание объекта класса SalesData
sales_data = SalesData(data)

# Очистка данных
sales_data.clean_data()

# Расчёт общей стоимости продаж
#sales_data.calculate_total_sales()

# Описательная статистика
print(sales_data.summary_statistics())

# Визуализация распределения продаж
sales_data.plot_sales_distribution()
```

**Объяснение:**

-   **SalesData**: Этот класс отвечает за обработку и анализ данных
    о продажах. Он принимает словарь с данными и превращает его в
    DataFrame с помощью pandas.

-   **Методы класса**:

    -   **clean\_data**: Метод для очистки данных от
        пропущенных значений.

    -   **calculate\_total\_sales**: Добавляет столбец для общей
        стоимости продаж (по формуле: Количество \* Цена).

    -   **summary\_statistics**: Выводит основные статистические данные
        о наборе данных, такие как среднее, стандартное отклонение
        и квантели.

    -   **plot\_sales\_distribution**: Строит гистограмму для
        отображения распределения общей стоимости продаж.

### 2. Интеграция классов с анализом данных и визуализацией

Используя объекты и методы, мы можем легко интегрировать различные этапы
анализа данных, включая очистку, агрегацию и визуализацию. Это упрощает
обработку больших наборов данных и делает код более модульным и гибким.

**Пример: Обработка данных с несколькими источниками**

Предположим, у нас есть несколько источников данных, и мы хотим
обработать их с использованием классов. Мы можем расширить наш класс для
работы с несколькими файлами.
```
import pandas as pd
import seaborn as sns
import matplotlib as plt


class MultiSourceSalesData:

    def __init__(self, *files):
        self.files = files #Множество файлов для обработки
        self.data = pd.DataFrame()


    def load_data(self):
	#"""Загрузить данные из нескольких файлов CSV."""
        for file in self.files:
            df = pd.read_csv(file)
            self.data = pd.concat([self.data, df], ignore_index=True)
  

    def clean_and_process_data(self):
    #"""Очистка и обработка данных."""
        self.data.dropna(inplace=True)
        self.data['TotalSales'] = self.data['Quantity']
        self.data['Price']
  

    def visualize_sales_by_product(self):
    #"""Группировка данных по продуктам и визуализация."""
        product_sales = self.data.groupby('Product')['TotalSales'].sum().reset_index()
        sns.barplot(x='Product', y='TotalSales', data=product_sales)
        plt.title('Общая стоимость продаж по продуктам')
		plt.show()

#Пример использования
multi_source_data = MultiSourceSalesData('sales\_data1.csv', 'sales\_data2.csv')
multi_source_data.load_data()
multi_source_data.clean_and_process_data()
multi_source_data.visualize_sales_by_product()
```

**Объяснение:**

-   **MultiSourceSalesData**: Класс для загрузки данных из нескольких
    CSV-файлов, их очистки и визуализации.

-   **load\_data**: Метод для загрузки данных из нескольких файлов и их
    объединения в один DataFrame.

-   **clean\_and\_process\_data**: Очистка данных от пропусков и
    добавление столбца с общей стоимостью продаж.

-   **visualize\_sales\_by\_product**: Группировка данных по продуктам и
    построение столбчатой диаграммы для отображения общей стоимости
    продаж по каждому продукту.

### 3. Преимущества использования классов в анализе данных:

-   **Структурированность**: Классы помогают организовать код, делая его
    более логичным и разделённым на компоненты, которые
    легко поддерживать.

-   **Гибкость**: Мы можем расширять классы новыми методами, изменять их
    поведение и легко интегрировать новые источники данных.

-   **Модульность**: Классы позволяют разделить проект на несколько
    частей, каждая из которых решает конкретную задачу, что упрощает
    тестирование и отладку.
